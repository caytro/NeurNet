#include "Perceptron.hpp"
#include "DataSample.hpp"
#include "DataSet.hpp"

#include <stdlib.h>
#include <numeric>
#include <cmath>
#include <cassert>
#include <algorithm>

using namespace std;

// Constructor

Perceptron::Perceptron(double biais): m_biais(biais)
{}

// Setters

void Perceptron::addInput(Perceptron& input, double weight) {
    m_dendrites.emplace_back(input, weight);
}

void Perceptron::setLearningRate(double learningRate)
{
    m_learningRate = learningRate;
}

// Getters


vector<Dendrite>& Perceptron::getDendrites()
{
    return m_dendrites;
}

double Perceptron::getLearningRate() const
{
    return m_learningRate;
}



// Others

vector<double> Perceptron::getWVector() const {
    vector<double> w;
    w.reserve(m_dendrites.size());

    for (const auto& d : m_dendrites)
        w.push_back(d.getWeight());   // un poids par dendrite

    return w;
}

void Perceptron::calcZ(const DataSet &dataSet)
{
    assert(dataSet.getDimension() == m_dendrites.size());
    m_z.assign(dataSet.getSamples().size(), m_biais);
    const auto& samples = dataSet.getSamples();
    const auto& w = getWVector();

    vector<double> result(samples.size());

    transform(samples.begin(), samples.end(),
                   result.begin(),
                   [&](const DataSample& s) {
                       const auto& x = s.getInput();
                       return inner_product(x.begin(), x.end(),
                                                 w.begin(), m_biais);
                   });

}




double Perceptron::activationFunction(double z) const
{
    return 1/(1 + exp(-z));
}

double Perceptron::calcLogLoss(const DataSet& dataSet) const
{


    return 0;
}





vectordouble Perceptron::getOutput() const {
    return m_output;
}


